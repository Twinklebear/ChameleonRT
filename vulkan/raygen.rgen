#version 460

#include "util.glsl"
#include "pcg_rng.glsl"
#include "lights.glsl"
#include "disney_bsdf.glsl"

struct MaterialParams {
    pack_float3 base_color;
    float metallic;

    float specular;
    float roughness;
    float specular_tint;
    float anisotropy;

    float sheen;
    float sheen_tint;
    float clearcoat;
    float clearcoat_gloss;

    float ior;
    float specular_transmission;
    vec2 pad;

    int color_tex_id;
    pack_uint3 tex_pad;
};

layout(binding = 0, set = 0) uniform accelerationStructureNV scene;
layout(binding = 1, set = 0, rgba8) uniform writeonly image2D framebuffer;
layout(binding = 2, set = 0, rgba32f) uniform image2D accum_buffer;

layout(binding = 3, set = 0, std140) uniform ViewParams {
    vec4 cam_pos;
    vec4 cam_du;
    vec4 cam_dv;
    vec4 cam_dir_top_left;
    int frame_id;
};

layout(binding = 4, set = 0, std430) buffer MaterialParamsBuffer {
    MaterialParams material_params[];
};

layout(binding = 5, set = 0, std430) buffer LightParamsBuffer {
    QuadLight lights[];
};

#ifdef REPORT_RAY_STATS
layout(binding = 6, set = 0, r16ui) uniform writeonly uimage2D ray_stats;
#endif

layout(binding = 0, set = 5) uniform sampler2D textures[];

layout(location = PRIMARY_RAY) rayPayloadNV RayPayload payload;
layout(location = OCCLUSION_RAY) rayPayloadNV bool occlusion_hit;

layout(shaderRecordNV) buffer SBT {
    uint32_t num_lights;
};

void unpack_material(inout DisneyMaterial mat, uint id, vec2 uv_coords) {
	MaterialParams p = material_params[nonuniformEXT(id)];
	if (p.color_tex_id < 0) {
		mat.base_color = unpack_float3(p.base_color);
	} else {
		mat.base_color = texture(textures[nonuniformEXT(p.color_tex_id)], uv_coords).xyz;
	}
	mat.metallic = p.metallic;
	mat.specular = p.specular;
	mat.roughness = p.roughness;
	mat.specular_tint = p.specular_tint;
	mat.anisotropy = p.anisotropy;
	mat.sheen = p.sheen;
	mat.sheen_tint = p.sheen_tint;
	mat.clearcoat = p.clearcoat;
	mat.clearcoat_gloss = p.clearcoat_gloss;
	mat.ior = p.ior;
	mat.specular_transmission = p.specular_transmission;
}

vec3 sample_direct_light(in const DisneyMaterial mat, in const vec3 hit_p, in const vec3 n,
	in const vec3 v_x, in const vec3 v_y, in const vec3 w_o, inout uint ray_count, inout PCGRand rng)
{
	vec3 illum = vec3(0.f);

	uint32_t light_id = uint32_t(pcg32_randomf(rng)) * num_lights;
	light_id = min(light_id, num_lights - 1);
	QuadLight light = lights[nonuniformEXT(light_id)];

    const uint32_t occlusion_flags = gl_RayFlagsOpaqueNV
        | gl_RayFlagsTerminateOnFirstHitNV
        | gl_RayFlagsSkipClosestHitShaderNV;

	// Sample the light to compute an incident light ray to this point
	{
		vec3 light_pos = sample_quad_light_position(light,
                vec2(pcg32_randomf(rng), pcg32_randomf(rng)));
		vec3 light_dir = light_pos - hit_p;
		float light_dist = length(light_dir);
		light_dir = normalize(light_dir);

		float light_pdf = quad_light_pdf(light, light_pos, hit_p, light_dir);
		float bsdf_pdf = disney_pdf(mat, n, w_o, light_dir, v_x, v_y);

        occlusion_hit = true;
        traceNV(scene, occlusion_flags, 0xff,
                OCCLUSION_RAY, 0, OCCLUSION_RAY, hit_p, EPSILON, light_dir, light_dist, OCCLUSION_RAY);
#ifdef REPORT_RAY_STATS
		++ray_count;
#endif
		if (light_pdf >= EPSILON && bsdf_pdf >= EPSILON && !occlusion_hit) {
			vec3 bsdf = disney_brdf(mat, n, w_o, light_dir, v_x, v_y);
			float w = power_heuristic(1.f, light_pdf, 1.f, bsdf_pdf);
			illum = bsdf * light.emission.rgb * abs(dot(light_dir, n)) * w / light_pdf;
		}
	}

	// Sample the BRDF to compute a light sample as well
	{
		vec3 w_i;
		float bsdf_pdf;
		vec3 bsdf = sample_disney_brdf(mat, n, w_o, v_x, v_y, rng, w_i, bsdf_pdf);
		
		float light_dist;
		vec3 light_pos;
		if (any(greaterThan(bsdf, vec3(0.f))) && bsdf_pdf >= EPSILON
			&& quad_intersect(light, hit_p, w_i, light_dist, light_pos))
		{
			float light_pdf = quad_light_pdf(light, light_pos, hit_p, w_i);
			if (light_pdf >= EPSILON) {
				float w = power_heuristic(1.f, bsdf_pdf, 1.f, light_pdf);
                occlusion_hit = true;
                traceNV(scene, occlusion_flags, 0xff,
                        OCCLUSION_RAY, 0, OCCLUSION_RAY, hit_p, EPSILON, w_i, light_dist, OCCLUSION_RAY);
#ifdef REPORT_RAY_STATS
				++ray_count;
#endif
				if (!occlusion_hit) {
					illum += bsdf * light.emission.rgb * abs(dot(w_i, n)) * w / bsdf_pdf;
				}
			}
		}
	}
	return illum;
}

void main() {
    const ivec2 pixel = ivec2(gl_LaunchIDNV.xy);
    const vec2 dims = vec2(gl_LaunchSizeNV.xy);
    PCGRand rng = get_rng(frame_id);
    vec2 d = (pixel + vec2(pcg32_randomf(rng), pcg32_randomf(rng))) / dims;

    vec3 ray_origin = cam_pos.xyz;
    vec3 ray_dir = normalize(d.x * cam_du.xyz + d.y * cam_dv.xyz + cam_dir_top_left.xyz);
    float t_min = 0;
    float t_max = 1e20f;

    DisneyMaterial mat;

	uint ray_count = 0;
	int bounce = 0;
	vec3 illum = vec3(0.f);
	vec3 path_throughput = vec3(1.f);
    do {
        traceNV(scene, gl_RayFlagsOpaqueNV, 0xff, PRIMARY_RAY, 0, PRIMARY_RAY,
                ray_origin, t_min, ray_dir, t_max, PRIMARY_RAY);
#ifdef REPORT_RAY_STATS
		++ray_count;
#endif
        // If we hit nothing, include the scene background color from the miss shader
        if (payload.dist < 0.f) {
            illum += path_throughput * payload.normal.rgb;
            break;
        }

		const vec3 w_o = -ray_dir;
		const vec3 hit_p = ray_origin + payload.dist * ray_dir;
		unpack_material(mat, payload.material_id, payload.uv);

		vec3 v_x, v_y;
		vec3 v_z = payload.normal;
		// For opaque objects (or in the future, thin ones) make the normal face forward
		if (mat.specular_transmission == 0.f && dot(w_o, v_z) < 0.0) {
			v_z = -v_z;
		}
		ortho_basis(v_x, v_y, v_z);

		illum += path_throughput * sample_direct_light(mat, hit_p, v_z, v_x, v_y, w_o, ray_count, rng);

		vec3 w_i;
		float pdf;
		vec3 bsdf = sample_disney_brdf(mat, v_z, w_o, v_x, v_y, rng, w_i, pdf);
		if (pdf < EPSILON || all(equal(bsdf, vec3(0.f)))) {
			break;
		}
		path_throughput *= bsdf * abs(dot(w_i, v_z)) / pdf;

		if (all(lessThan(path_throughput, vec3(EPSILON)))) {
			break;
		}

		ray_origin = hit_p;
		ray_dir = w_i;
		t_min = EPSILON;
		t_max = 1e20f;

		++bounce;
	} while (bounce < MAX_PATH_DEPTH);

    vec4 accum_color = imageLoad(accum_buffer, pixel);
	accum_color = (vec4(illum, 1.0) + frame_id * accum_color) / (frame_id + 1);
    imageStore(accum_buffer, pixel, accum_color);

    accum_color.xyz = vec3(linear_to_srgb(accum_color.x), linear_to_srgb(accum_color.y),
            linear_to_srgb(accum_color.z));
    imageStore(framebuffer, pixel, vec4(accum_color.xyz, 1.f));

#ifdef REPORT_RAY_STATS
    imageStore(ray_stats, pixel, uvec4(ray_count));
#endif
}

