#version 460

#include "util.glsl"
#include "lcg_rng.glsl"

#define NUM_AO_SAMPLES 4

layout(binding = 0, set = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, set = 0, rgba8) uniform writeonly image2D framebuffer;
layout(binding = 2, set = 0, rgba32f) uniform image2D accum_buffer;

layout(binding = 3, set = 0, std140) uniform ViewParams {
    vec4 cam_pos;
    vec4 cam_du;
    vec4 cam_dv;
    vec4 cam_dir_top_left;
    int frame_id;
    int samples_per_pixel;
};

#ifdef REPORT_RAY_STATS
layout(binding = 6, set = 0, r16ui) uniform writeonly uimage2D ray_stats;
#endif

layout(location = PRIMARY_RAY) rayPayloadEXT AORayPayload payload;
layout(location = OCCLUSION_RAY) rayPayloadEXT int n_occluded;

layout(shaderRecordEXT) buffer SBT {
    uint32_t num_lights;
};

void main() {
    const ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
    const vec2 dims = vec2(gl_LaunchSizeEXT.xy);

    uint ray_count = 0;
    vec3 illum = vec3(0.f);
    for (int s = 0; s < samples_per_pixel; ++s) {
        LCGRand rng = get_rng(frame_id * samples_per_pixel + s);
        vec2 d = (pixel + vec2(lcg_randomf(rng), lcg_randomf(rng))) / dims;

        vec3 ray_origin = cam_pos.xyz;
        vec3 ray_dir = normalize(d.x * cam_du.xyz + d.y * cam_dv.xyz + cam_dir_top_left.xyz);
        float t_min = 0;
        float t_max = 1e20f;

        traceRayEXT(scene, gl_RayFlagsOpaqueEXT, 0xff, PRIMARY_RAY, 1, PRIMARY_RAY,
                ray_origin, t_min, ray_dir, t_max, PRIMARY_RAY);
#ifdef REPORT_RAY_STATS
        ++ray_count;
#endif
        // If we hit nothing, include the scene background color from the miss shader
        if (payload.dist > 0.f) {
            ray_origin = ray_origin + payload.dist * ray_dir;

            vec3 v_x, v_y;
            vec3 v_z = payload.normal;
            // For opaque objects (or in the future, thin ones) make the normal face forward
            if (dot(ray_dir, v_z) > 0.f) {
                v_z = -v_z;
            }
            ortho_basis(v_x, v_y, v_z);

            const uint32_t occlusion_flags = gl_RayFlagsOpaqueEXT
                | gl_RayFlagsTerminateOnFirstHitEXT
                | gl_RayFlagsSkipClosestHitShaderEXT;

            n_occluded = NUM_AO_SAMPLES;
#ifdef REPORT_RAY_STATS
            ray_count += NUM_AO_SAMPLES;
#endif
            for (int i = 0; i < NUM_AO_SAMPLES; ++i) {
                const float theta = sqrt(lcg_randomf(rng));
                const float phi = 2.f * M_PI * lcg_randomf(rng);

                const float x = cos(phi) * theta;
                const float y = sin(phi) * theta;
                const float z = sqrt(1.f - theta * theta);

                ray_dir = normalize(x * v_x + y * v_y + z * v_z);
                traceRayEXT(scene,
                            occlusion_flags,
                            0xff,
                            PRIMARY_RAY,
                            1,
                            OCCLUSION_RAY,
                            ray_origin,
                            EPSILON,
                            ray_dir,
                            1e20f,
                            OCCLUSION_RAY);
            }
            illum += 1.f - vec3(n_occluded) / NUM_AO_SAMPLES;
        }
    }
    illum = illum / samples_per_pixel;

    vec4 accum_color = imageLoad(accum_buffer, pixel);
    accum_color = (vec4(illum, 1.0) + frame_id * accum_color) / (frame_id + 1);
    imageStore(accum_buffer, pixel, accum_color);

    accum_color.xyz = vec3(linear_to_srgb(accum_color.x), linear_to_srgb(accum_color.y),
            linear_to_srgb(accum_color.z));
    imageStore(framebuffer, pixel, vec4(accum_color.xyz, 1.f));

#ifdef REPORT_RAY_STATS
    imageStore(ray_stats, pixel, uvec4(ray_count));
#endif
}

